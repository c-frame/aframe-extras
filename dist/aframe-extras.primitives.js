(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

require('./src/primitives');

},{"./src/primitives":8}],2:[function(require,module,exports){
"use strict";

module.exports = {
  "size": 5,
  "cellSize": 10,
  "extrudeSettings": {
    "amount": 1,
    "bevelEnabled": true,
    "bevelSegments": 1,
    "steps": 1,
    "bevelSize": 0.5,
    "bevelThickness": 0.5
  },
  "autogenerated": true,
  "cells": [{
    "q": -1,
    "r": 0,
    "s": 1,
    "h": 1,
    "walkable": true,
    "userData": {}
  }, {
    "q": 0,
    "r": -1,
    "s": 1,
    "h": 1,
    "walkable": true,
    "userData": {}
  }, {
    "q": 0,
    "r": 0,
    "s": 0,
    "h": 1,
    "walkable": true,
    "userData": {}
  }, {
    "q": 1,
    "r": -1,
    "s": 0,
    "h": 1,
    "walkable": true,
    "userData": {}
  }, {
    "q": -1,
    "r": 1,
    "s": 0,
    "h": 0,
    "walkable": true,
    "userData": {}
  }, {
    "q": 0,
    "r": 1,
    "s": -1,
    "h": 0,
    "walkable": true,
    "userData": {}
  }, {
    "q": 1,
    "r": 0,
    "s": -1,
    "h": 0,
    "walkable": true,
    "userData": {}
  }]
};

},{}],3:[function(require,module,exports){
"use strict";

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var vg = module.exports = { VERSION: "0.1.1", PI: Math.PI, TAU: 2 * Math.PI, DEG_TO_RAD: .0174532925, RAD_TO_DEG: 57.2957795, SQRT3: Math.sqrt(3), TILE: "tile", ENT: "entity", STR: "structure", HEX: "hex", SQR: "square", ABS: "abstract" };vg.Board = function (e, t) {
  if (!e) throw new Error("You must pass in a grid system for the board to use.");this.tiles = [], this.tileGroup = null, this.group = new THREE.Object3D(), this.grid = null, this.overlay = null, this.finder = new vg.AStarFinder(t), vg.Loader.init(), this.setGrid(e);
}, vg.Board.prototype = { setEntityOnTile: function setEntityOnTile(e, t) {
    var i = this.grid.cellToPixel(t.cell);e.position.copy(i), e.position.y += e.heightOffset || 0, e.tile && (e.tile.entity = null), e.tile = t, t.entity = e;
  }, addTile: function addTile(e) {
    var t = this.tiles.indexOf(e);-1 === t && (this.tiles.push(e), this.snapTileToGrid(e), e.position.y = 0, this.tileGroup.add(e.mesh), this.grid.add(e.cell), e.cell.tile = e);
  }, removeTile: function removeTile(e) {
    if (e) {
      var t = this.tiles.indexOf(e);this.grid.remove(e.cell), -1 !== t && this.tiles.splice(t, 1), e.dispose();
    }
  }, removeAllTiles: function removeAllTiles() {
    if (this.tileGroup) for (var e = this.tileGroup.children, t = 0; t < e.length; t++) {
      this.tileGroup.remove(e[t]);
    }
  }, getTileAtCell: function getTileAtCell(e) {
    var t = this.grid.cellToHash(e);return e.tile || ("undefined" != typeof this.grid.cells[t] ? this.grid.cells[t].tile : null);
  }, snapToGrid: function snapToGrid(e) {
    var t = this.grid.pixelToCell(e);e.copy(this.grid.cellToPixel(t));
  }, snapTileToGrid: function snapTileToGrid(e) {
    if (e.cell) e.position.copy(this.grid.cellToPixel(e.cell));else {
      var t = this.grid.pixelToCell(e.position);e.position.copy(this.grid.cellToPixel(t));
    }return e;
  }, getRandomTile: function getRandomTile() {
    var e = vg.Tools.randomInt(0, this.tiles.length - 1);return this.tiles[e];
  }, findPath: function findPath(e, t, i) {
    return this.finder.findPath(e.cell, t.cell, i, this.grid);
  }, setGrid: function setGrid(e) {
    this.group.remove(this.tileGroup), this.grid && e !== this.grid && (this.removeAllTiles(), this.tiles.forEach(function (e) {
      this.grid.remove(e.cell), e.dispose();
    }), this.grid.dispose()), this.grid = e, this.tiles = [], this.tileGroup = new THREE.Object3D(), this.group.add(this.tileGroup);
  }, generateOverlay: function generateOverlay(e) {
    var t = new THREE.LineBasicMaterial({ color: 0, opacity: .3 });this.overlay && this.group.remove(this.overlay), this.overlay = new THREE.Object3D(), this.grid.generateOverlay(e, this.overlay, t), this.group.add(this.overlay);
  }, generateTilemap: function generateTilemap(e) {
    this.reset();var t = this.grid.generateTiles(e);this.tiles = t, this.tileGroup = new THREE.Object3D();for (var i = 0; i < t.length; i++) {
      this.tileGroup.add(t[i].mesh);
    }this.group.add(this.tileGroup);
  }, reset: function reset() {
    this.removeAllTiles(), this.tileGroup && this.group.remove(this.tileGroup);
  } }, vg.Board.prototype.constructor = vg.Board, vg.Cell = function (e, t, i, s) {
  this.q = e || 0, this.r = t || 0, this.s = i || 0, this.h = s || 1, this.tile = null, this.userData = {}, this.walkable = !0, this._calcCost = 0, this._priority = 0, this._visited = !1, this._parent = null, this.uniqueID = vg.LinkedList.generateID();
}, vg.Cell.prototype = { set: function set(e, t, i) {
    return this.q = e, this.r = t, this.s = i, this;
  }, copy: function copy(e) {
    return this.q = e.q, this.r = e.r, this.s = e.s, this.h = e.h, this.tile = e.tile || null, this.userData = e.userData || {}, this.walkable = e.walkable, this;
  }, add: function add(e) {
    return this.q += e.q, this.r += e.r, this.s += e.s, this;
  }, equals: function equals(e) {
    return this.q === e.q && this.r === e.r && this.s === e.s;
  } }, vg.Cell.prototype.constructor = vg.Cell, vg.HexGrid = function (e) {
  e = e || {}, this.type = vg.HEX, this.size = 5, this.cellSize = "undefined" == typeof e.cellSize ? 10 : e.cellSize, this.cells = {}, this.numCells = 0, this.extrudeSettings = null, this.autogenerated = !1;var t,
      i = [];for (t = 0; 6 > t; t++) {
    i.push(this._createVertex(t));
  }for (this.cellShape = new THREE.Shape(), this.cellShape.moveTo(i[0].x, i[0].y), t = 1; 6 > t; t++) {
    this.cellShape.lineTo(i[t].x, i[t].y);
  }this.cellShape.lineTo(i[0].x, i[0].y), this.cellShape.autoClose = !0, this.cellGeo = new THREE.Geometry(), this.cellGeo.vertices = i, this.cellGeo.verticesNeedUpdate = !0, this.cellShapeGeo = new THREE.ShapeGeometry(this.cellShape), this._cellWidth = 2 * this.cellSize, this._cellLength = .5 * vg.SQRT3 * this._cellWidth, this._hashDelimeter = ".", this._directions = [new vg.Cell(1, -1, 0), new vg.Cell(1, 0, -1), new vg.Cell(0, 1, -1), new vg.Cell(-1, 1, 0), new vg.Cell(-1, 0, 1), new vg.Cell(0, -1, 1)], this._diagonals = [new vg.Cell(2, -1, -1), new vg.Cell(1, 1, -2), new vg.Cell(-1, 2, -1), new vg.Cell(-2, 1, 1), new vg.Cell(-1, -1, 2), new vg.Cell(1, -2, 1)], this._list = [], this._vec3 = new THREE.Vector3(), this._cel = new vg.Cell(), this._conversionVec = new THREE.Vector3(), this._geoCache = [], this._matCache = [];
}, vg.HexGrid.TWO_THIRDS = 2 / 3, vg.HexGrid.prototype = { cellToPixel: function cellToPixel(e) {
    return this._vec3.x = e.q * this._cellWidth * .75, this._vec3.y = e.h, this._vec3.z = -((e.s - e.r) * this._cellLength * .5), this._vec3;
  }, pixelToCell: function pixelToCell(e) {
    var t = e.x * (vg.HexGrid.TWO_THIRDS / this.cellSize),
        i = (-e.x / 3 + vg.SQRT3 / 3 * e.z) / this.cellSize;return this._cel.set(t, i, -t - i), this._cubeRound(this._cel);
  }, getCellAt: function getCellAt(e) {
    var t = e.x * (vg.HexGrid.TWO_THIRDS / this.cellSize),
        i = (-e.x / 3 + vg.SQRT3 / 3 * e.z) / this.cellSize;return this._cel.set(t, i, -t - i), this._cubeRound(this._cel), this.cells[this.cellToHash(this._cel)];
  }, getNeighbors: function getNeighbors(e, t, i) {
    var s,
        n,
        l = this._directions.length;for (this._list.length = 0, s = 0; l > s; s++) {
      this._cel.copy(e), this._cel.add(this._directions[s]), n = this.cells[this.cellToHash(this._cel)], !n || i && !i(e, n) || this._list.push(n);
    }if (t) for (s = 0; l > s; s++) {
      this._cel.copy(e), this._cel.add(this._diagonals[s]), n = this.cells[this.cellToHash(this._cel)], !n || i && !i(e, n) || this._list.push(n);
    }return this._list;
  }, getRandomCell: function getRandomCell() {
    var e,
        t = 0,
        i = vg.Tools.randomInt(0, this.numCells);for (e in this.cells) {
      if (t === i) return this.cells[e];t++;
    }return this.cells[e];
  }, cellToHash: function cellToHash(e) {
    return e.q + this._hashDelimeter + e.r + this._hashDelimeter + e.s;
  }, distance: function distance(e, t) {
    var i = Math.max(Math.abs(e.q - t.q), Math.abs(e.r - t.r), Math.abs(e.s - t.s));return i += t.h - e.h;
  }, clearPath: function clearPath() {
    var e, t;for (e in this.cells) {
      t = this.cells[e], t._calcCost = 0, t._priority = 0, t._parent = null, t._visited = !1;
    }
  }, traverse: function traverse(e) {
    var t;for (t in this.cells) {
      e(this.cells[t]);
    }
  }, generateTile: function generateTile(e, t, i) {
    var s = Math.abs(e.h);1 > s && (s = 1);var n = this._geoCache[s];n || (this.extrudeSettings.amount = s, n = new THREE.ExtrudeGeometry(this.cellShape, this.extrudeSettings), this._geoCache[s] = n);var l = new vg.Tile({ size: this.cellSize, scale: t, cell: e, geometry: n, material: i });return e.tile = l, l;
  }, generateTiles: function generateTiles(e) {
    e = e || {};var t = [],
        i = { tileScale: .95, cellSize: this.cellSize, material: null, extrudeSettings: { amount: 1, bevelEnabled: !0, bevelSegments: 1, steps: 1, bevelSize: .5, bevelThickness: .5 } };i = vg.Tools.merge(i, e), this.cellSize = i.cellSize, this._cellWidth = 2 * this.cellSize, this._cellLength = .5 * vg.SQRT3 * this._cellWidth, this.autogenerated = !0, this.extrudeSettings = i.extrudeSettings;var s, n, l;for (s in this.cells) {
      l = this.cells[s], n = this.generateTile(l, i.tileScale, i.material), n.position.copy(this.cellToPixel(l)), n.position.y = 0, t.push(n);
    }return t;
  }, generateTilePoly: function generateTilePoly(e) {
    e || (e = new THREE.MeshBasicMaterial({ color: 2405631 }));var t = new THREE.Mesh(this.cellShapeGeo, e);return this._vec3.set(1, 0, 0), t.rotateOnAxis(this._vec3, vg.PI / 2), t;
  }, generate: function generate(e) {
    e = e || {}, this.size = "undefined" == typeof e.size ? this.size : e.size;var t, i, s, n;for (t = -this.size; t < this.size + 1; t++) {
      for (i = -this.size; i < this.size + 1; i++) {
        s = -t - i, Math.abs(t) <= this.size && Math.abs(i) <= this.size && Math.abs(s) <= this.size && (n = new vg.Cell(t, i, s), this.add(n));
      }
    }
  }, generateOverlay: function generateOverlay(e, t, i) {
    var s,
        n,
        l,
        r = this.cellShape.createPointsGeometry();for (s = -e; e + 1 > s; s++) {
      for (n = -e; e + 1 > n; n++) {
        if (l = -s - n, Math.abs(s) <= e && Math.abs(n) <= e && Math.abs(l) <= e) {
          this._cel.set(s, n, l);var h = new THREE.Line(r, i);h.position.copy(this.cellToPixel(this._cel)), h.rotation.x = 90 * vg.DEG_TO_RAD, t.add(h);
        }
      }
    }
  }, add: function add(e) {
    var t = this.cellToHash(e);if (!this.cells[t]) return this.cells[t] = e, this.numCells++, e;
  }, remove: function remove(e) {
    var t = this.cellToHash(e);this.cells[t] && (delete this.cells[t], this.numCells--);
  }, dispose: function dispose() {
    this.cells = null, this.numCells = 0, this.cellShape = null, this.cellGeo.dispose(), this.cellGeo = null, this.cellShapeGeo.dispose(), this.cellShapeGeo = null, this._list = null, this._vec3 = null, this._conversionVec = null, this._geoCache = null, this._matCache = null;
  }, load: function load(e, t, i) {
    var s = this;vg.Tools.getJSON({ url: e, callback: function callback(e) {
        s.fromJSON(e), t.call(i || null, e);
      }, cache: !1, scope: s });
  }, fromJSON: function fromJSON(e) {
    var t,
        i,
        s = e.cells;for (this.cells = {}, this.numCells = 0, this.size = e.size, this.cellSize = e.cellSize, this._cellWidth = 2 * this.cellSize, this._cellLength = .5 * vg.SQRT3 * this._cellWidth, this.extrudeSettings = e.extrudeSettings, this.autogenerated = e.autogenerated, t = 0; t < s.length; t++) {
      i = new vg.Cell(), i.copy(s[t]), this.add(i);
    }
  }, toJSON: function toJSON() {
    var e,
        t,
        i = { size: this.size, cellSize: this.cellSize, extrudeSettings: this.extrudeSettings, autogenerated: this.autogenerated },
        s = [];for (t in this.cells) {
      e = this.cells[t], s.push({ q: e.q, r: e.r, s: e.s, h: e.h, walkable: e.walkable, userData: e.userData });
    }return i.cells = s, i;
  }, _createVertex: function _createVertex(e) {
    var t = vg.TAU / 6 * e;return new THREE.Vector3(this.cellSize * Math.cos(t), this.cellSize * Math.sin(t), 0);
  }, _cubeRound: function _cubeRound(e) {
    var t = Math.round(e.q),
        i = Math.round(e.r),
        s = Math.round(e.s),
        n = Math.abs(t - e.q),
        l = Math.abs(i - e.r),
        r = Math.abs(s - e.s);return n > l && n > r ? t = -i - s : l > r ? i = -t - s : s = -t - i, this._cel.set(t, i, s);
  } }, vg.HexGrid.prototype.constructor = vg.HexGrid, vg.SqrGrid = function (e) {
  e = e || {}, this.type = vg.SQR, this.size = 5, this.cellSize = "undefined" == typeof e.cellSize ? 10 : e.cellSize, this.cells = {}, this.numCells = 0, this.extrudeSettings = null, this.autogenerated = !1;var t = [];t.push(new THREE.Vector3()), t.push(new THREE.Vector3(-this.cellSize, this.cellSize)), t.push(new THREE.Vector3(this.cellSize, this.cellSize)), t.push(new THREE.Vector3(this.cellSize, -this.cellSize)), this.cellShape = new THREE.Shape(), this.cellShape.moveTo(-this.cellSize, -this.cellSize), this.cellShape.lineTo(-this.cellSize, this.cellSize), this.cellShape.lineTo(this.cellSize, this.cellSize), this.cellShape.lineTo(this.cellSize, -this.cellSize), this.cellShape.lineTo(-this.cellSize, -this.cellSize), this.cellGeo = new THREE.Geometry(), this.cellGeo.vertices = t, this.cellGeo.verticesNeedUpdate = !0, this.cellShapeGeo = new THREE.ShapeGeometry(this.cellShape), this._fullCellSize = 2 * this.cellSize, this._hashDelimeter = ".", this._directions = [new vg.Cell(1, 0, 0), new vg.Cell(0, -1, 0), new vg.Cell(-1, 0, 0), new vg.Cell(0, 1, 0)], this._diagonals = [new vg.Cell(-1, -1, 0), new vg.Cell(-1, 1, 0), new vg.Cell(1, 1, 0), new vg.Cell(1, -1, 0)], this._list = [], this._vec3 = new THREE.Vector3(), this._cel = new vg.Cell(), this._conversionVec = new THREE.Vector3(), this._geoCache = [], this._matCache = [];
}, vg.SqrGrid.prototype = { cellToPixel: function cellToPixel(e) {
    return this._vec3.x = e.q * this._fullCellSize, this._vec3.y = e.h, this._vec3.z = e.r * this._fullCellSize, this._vec3;
  }, pixelToCell: function pixelToCell(e) {
    var t = Math.round(e.x / this._fullCellSize),
        i = Math.round(e.z / this._fullCellSize);return this._cel.set(t, i, 0);
  }, getCellAt: function getCellAt(e) {
    var t = Math.round(e.x / this._fullCellSize),
        i = Math.round(e.z / this._fullCellSize);return this._cel.set(t, i), this.cells[this.cellToHash(this._cel)];
  }, getNeighbors: function getNeighbors(e, t, i) {
    var s,
        n,
        l = this._directions.length;for (this._list.length = 0, s = 0; l > s; s++) {
      this._cel.copy(e), this._cel.add(this._directions[s]), n = this.cells[this.cellToHash(this._cel)], !n || i && !i(e, n) || this._list.push(n);
    }if (t) for (s = 0; l > s; s++) {
      this._cel.copy(e), this._cel.add(this._diagonals[s]), n = this.cells[this.cellToHash(this._cel)], !n || i && !i(e, n) || this._list.push(n);
    }return this._list;
  }, getRandomCell: function getRandomCell() {
    var e,
        t = 0,
        i = vg.Tools.randomInt(0, this.numCells);for (e in this.cells) {
      if (t === i) return this.cells[e];t++;
    }return this.cells[e];
  }, cellToHash: function cellToHash(e) {
    return e.q + this._hashDelimeter + e.r;
  }, distance: function distance(e, t) {
    var i = Math.max(Math.abs(e.q - t.q), Math.abs(e.r - t.r));return i += t.h - e.h;
  }, clearPath: function clearPath() {
    var e, t;for (e in this.cells) {
      t = this.cells[e], t._calcCost = 0, t._priority = 0, t._parent = null, t._visited = !1;
    }
  }, traverse: function traverse(e) {
    var t;for (t in this.cells) {
      e(this.cells[t]);
    }
  }, generateTile: function generateTile(e, t, i) {
    var s = Math.abs(e.h);1 > s && (s = 1);var n = this._geoCache[s];n || (this.extrudeSettings.amount = s, n = new THREE.ExtrudeGeometry(this.cellShape, this.extrudeSettings), this._geoCache[s] = n);var l = new vg.Tile({ size: this.cellSize, scale: t, cell: e, geometry: n, material: i });return e.tile = l, l;
  }, generateTiles: function generateTiles(e) {
    e = e || {};var t = [],
        i = { tileScale: .95, cellSize: this.cellSize, material: null, extrudeSettings: { amount: 1, bevelEnabled: !0, bevelSegments: 1, steps: 1, bevelSize: .5, bevelThickness: .5 } };i = vg.Tools.merge(i, e), this.cellSize = i.cellSize, this._fullCellSize = 2 * this.cellSize, this.autogenerated = !0, this.extrudeSettings = i.extrudeSettings;var s, n, l;for (s in this.cells) {
      l = this.cells[s], n = this.generateTile(l, i.tileScale, i.material), n.position.copy(this.cellToPixel(l)), n.position.y = 0, t.push(n);
    }return t;
  }, generateTilePoly: function generateTilePoly(e) {
    e || (e = new THREE.MeshBasicMaterial({ color: 2405631 }));var t = new THREE.Mesh(this.cellShapeGeo, e);return this._vec3.set(1, 0, 0), t.rotateOnAxis(this._vec3, vg.PI / 2), t;
  }, generate: function generate(e) {
    e = e || {}, this.size = "undefined" == typeof e.size ? this.size : e.size;var t,
        i,
        s,
        n = Math.ceil(this.size / 2);for (t = -n; n > t; t++) {
      for (i = -n; n > i; i++) {
        s = new vg.Cell(t, i + 1), this.add(s);
      }
    }
  }, generateOverlay: function generateOverlay(e, t, i) {
    var s,
        n,
        l = Math.ceil(e / 2);for (s = -l; l > s; s++) {
      for (n = -l; l > n; n++) {
        this._cel.set(s, n);var r = new THREE.Line(this.cellGeo, i);r.position.copy(this.cellToPixel(this._cel)), r.rotation.x = 90 * vg.DEG_TO_RAD, t.add(r);
      }
    }
  }, add: function add(e) {
    var t = this.cellToHash(e);if (!this.cells[t]) return this.cells[t] = e, this.numCells++, e;
  }, remove: function remove(e) {
    var t = this.cellToHash(e);this.cells[t] && (delete this.cells[t], this.numCells--);
  }, dispose: function dispose() {
    this.cells = null, this.numCells = 0, this.cellShape = null, this.cellGeo.dispose(), this.cellGeo = null, this.cellShapeGeo.dispose(), this.cellShapeGeo = null, this._list = null, this._vec3 = null, this._conversionVec = null, this._geoCache = null, this._matCache = null;
  }, load: function load(e, t, i) {
    vg.Tools.getJSON({ url: e, callback: function callback(e) {
        this.fromJSON(e), t.call(i || null, e);
      }, cache: !1, scope: this });
  }, fromJSON: function fromJSON(e) {
    var t,
        i,
        s = e.cells;for (this.cells = {}, this.numCells = 0, this.size = e.size, this.cellSize = e.cellSize, this._fullCellSize = 2 * this.cellSize, this.extrudeSettings = e.extrudeSettings, this.autogenerated = e.autogenerated, t = 0; t < s.length; t++) {
      i = new vg.Cell(), i.copy(s[t]), this.add(i);
    }
  }, toJSON: function toJSON() {
    var e,
        t,
        i = { size: this.size, cellSize: this.cellSize, extrudeSettings: this.extrudeSettings, autogenerated: this.autogenerated },
        s = [];for (t in this.cells) {
      e = this.cells[t], s.push({ q: e.q, r: e.r, s: e.s, h: e.h, walkable: e.walkable, userData: e.userData });
    }return i.cells = s, i;
  } }, vg.SqrGrid.prototype.constructor = vg.SqrGrid, vg.Tile = function (e) {
  e = e || {};var t = { cell: null, geometry: null, material: null };if (t = vg.Tools.merge(t, e), !t.cell || !t.geometry) throw new Error("Missing vg.Tile configuration");this.cell = t.cell, this.cell.tile && this.cell.tile !== this && this.cell.tile.dispose(), this.cell.tile = this, this.uniqueID = vg.Tools.generateID(), this.geometry = t.geometry, this.material = t.material, this.material || (this.material = new THREE.MeshPhongMaterial({ color: vg.Tools.randomizeRGB("30, 30, 30", 13) })), this.objectType = vg.TILE, this.entity = null, this.userData = {}, this.selected = !1, this.highlight = "0x0084cc", this.mesh = new THREE.Mesh(this.geometry, this.material), this.mesh.userData.structure = this, this.position = this.mesh.position, this.rotation = this.mesh.rotation, this.rotation.x = -90 * vg.DEG_TO_RAD, this.mesh.scale.set(t.scale, t.scale, 1), this.material.emissive ? this._emissive = this.material.emissive.getHex() : this._emissive = null;
}, vg.Tile.prototype = { select: function select() {
    return this.material.emissive && this.material.emissive.setHex(this.highlight), this.selected = !0, this;
  }, deselect: function deselect() {
    return null !== this._emissive && this.material.emissive && this.material.emissive.setHex(this._emissive), this.selected = !1, this;
  }, toggle: function toggle() {
    return this.selected ? this.deselect() : this.select(), this;
  }, dispose: function dispose() {
    this.cell && this.cell.tile && (this.cell.tile = null), this.cell = null, this.position = null, this.rotation = null, this.mesh.parent && this.mesh.parent.remove(this.mesh), this.mesh.userData.structure = null, this.mesh = null, this.material = null, this.userData = null, this.entity = null, this.geometry = null, this._emissive = null;
  } }, vg.Tile.prototype.constructor = vg.Tile, function () {
  var e = function e() {
    this.obj = null, this.next = null, this.prev = null, this.free = !0;
  },
      t = function t() {
    this.first = null, this.last = null, this.length = 0, this.objToNodeMap = {}, this.uniqueID = Date.now() + "" + Math.floor(1e3 * Math.random()), this.sortArray = [];
  };t.generateID = function () {
    return Math.random().toString(36).slice(2) + Date.now();
  }, t.prototype = { getNode: function getNode(e) {
      return this.objToNodeMap[e.uniqueID];
    }, addNode: function addNode(i) {
      var s = new e();if (!i.uniqueID) try {
        i.uniqueID = t.generateID();
      } catch (n) {
        return console.error("[LinkedList.addNode] obj passed is immutable: cannot attach necessary identifier"), null;
      }return s.obj = i, s.free = !1, this.objToNodeMap[i.uniqueID] = s, s;
    }, swapObjects: function swapObjects(e, t) {
      this.objToNodeMap[e.obj.uniqueID] = null, this.objToNodeMap[t.uniqueID] = e, e.obj = t;
    }, add: function add(e) {
      var t = this.objToNodeMap[e.uniqueID];if (t) {
        if (t.free === !1) return;t.obj = e, t.free = !1, t.next = null, t.prev = null;
      } else t = this.addNode(e);if (this.first) {
        if (!this.last) throw new Error("[LinkedList.add] No last in the list -- that shouldn't happen here");this.last.next = t, t.prev = this.last, this.last = t, t.next = null;
      } else this.first = t, this.last = t, t.next = null, t.prev = null;this.length++, this.showDebug && this.dump("after add");
    }, has: function has(e) {
      return !!this.objToNodeMap[e.uniqueID];
    }, moveUp: function moveUp(e) {
      this.dump("before move up");var t = this.getNode(e);if (!t) throw "Oops, trying to move an object that isn't in the list";if (t.prev) {
        var i = t.prev,
            s = i.prev;t == this.last && (this.last = i);var n = t.next;s && (s.next = t), t.next = i, t.prev = i.prev, i.next = n, i.prev = t, this.first == i && (this.first = t);
      }
    }, moveDown: function moveDown(e) {
      var t = this.getNode(e);if (!t) throw "Oops, trying to move an object that isn't in the list";if (t.next) {
        var i = t.next;this.moveUp(i.obj), this.last == i && (this.last = t);
      }
    }, sort: function sort(e) {
      var t,
          i,
          s = this.sortArray,
          n = this.first;for (s.length = 0; n;) {
        s.push(n.obj), n = n.next;
      }for (this.clear(), s.sort(e), i = s.length, t = 0; i > t; t++) {
        this.add(s[t]);
      }
    }, remove: function remove(e) {
      var t = this.getNode(e);return !t || t.free ? !1 : (t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.prev || (this.first = t.next), t.next || (this.last = t.prev), t.free = !0, t.prev = null, t.next = null, this.length--, !0);
    }, shift: function shift() {
      var e = this.first;return 0 === this.length ? null : (e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), this.first = e.next, e.next || (this.last = null), e.free = !0, e.prev = null, e.next = null, this.length--, e.obj);
    }, pop: function pop() {
      var e = this.last;return 0 === this.length ? null : (e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), this.last = e.prev, e.prev || (this.first = null), e.free = !0, e.prev = null, e.next = null, this.length--, e.obj);
    }, concat: function concat(e) {
      for (var t = e.first; t;) {
        this.add(t.obj), t = t.next;
      }
    }, clear: function clear() {
      for (var e = this.first; e;) {
        e.free = !0, e = e.next;
      }this.first = null, this.length = 0;
    }, dispose: function dispose() {
      for (var e = this.first; e;) {
        e.obj = null, e = e.next;
      }this.first = null, this.objToNodeMap = null;
    }, dump: function dump(e) {
      console.log("====================" + e + "=====================");for (var t = this.first; t;) {
        console.log("{" + t.obj.toString() + "} previous=" + (t.prev ? t.prev.obj : "NULL")), t = t.next();
      }console.log("==================================="), console.log("Last: {" + (this.last ? this.last.obj : "NULL") + "} First: {" + (this.first ? this.first.obj : "NULL") + "}");
    } }, t.prototype.constructor = t, vg.LinkedList = t;
}(), function () {
  var e = function e(_e, t, i, s, n) {
    this._listener = t, this.isOnce = i, this.context = s, this.signal = _e, this._priority = n || 0;
  };e.prototype = { active: !0, params: null, execute: function execute(e) {
      var t, i;return this.active && this._listener && (i = this.params ? this.params.concat(e) : e, t = this._listener.apply(this.context, i), this.isOnce && this.detach()), t;
    }, detach: function detach() {
      return this.isBound() ? this.signal.remove(this._listener, this.context) : null;
    }, isBound: function isBound() {
      return !!this.signal && !!this._listener;
    }, _destroy: function _destroy() {
      delete this.signal, delete this._listener, delete this.context;
    }, toString: function toString() {
      return "[SignalBinding isOnce:" + this.isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
    } }, e.prototype.constructor = e;var t = function t() {
    this._bindings = [], this._prevParams = null;var e = this;this.dispatch = function () {
      t.prototype.dispatch.apply(e, arguments);
    };
  };t.prototype = { memorize: !1, _shouldPropagate: !0, active: !0, validateListener: function validateListener(e, t) {
      if ("function" != typeof e) throw new Error("Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", t));
    }, _registerListener: function _registerListener(t, i, s, n) {
      var l,
          r = this._indexOfListener(t, s);if (-1 !== r) {
        if (l = this._bindings[r], l.isOnce !== i) throw new Error("You cannot add" + (i ? "" : "Once") + "() then add" + (i ? "Once" : "") + "() the same listener without removing the relationship first.");
      } else l = new e(this, t, i, s, n), this._addBinding(l);return this.memorize && this._prevParams && l.execute(this._prevParams), l;
    }, _addBinding: function _addBinding(e) {
      var t = this._bindings.length;do {
        t--;
      } while (this._bindings[t] && e._priority <= this._bindings[t]._priority);this._bindings.splice(t + 1, 0, e);
    }, _indexOfListener: function _indexOfListener(e, t) {
      for (var i, s = this._bindings.length; s--;) {
        if (i = this._bindings[s], i._listener === e && i.context === t) return s;
      }return -1;
    }, has: function has(e, t) {
      return -1 !== this._indexOfListener(e, t);
    }, add: function add(e, t, i) {
      return this.validateListener(e, "add"), this._registerListener(e, !1, t, i);
    }, addOnce: function addOnce(e, t, i) {
      return this.validateListener(e, "addOnce"), this._registerListener(e, !0, t, i);
    }, remove: function remove(e, t) {
      this.validateListener(e, "remove");var i = this._indexOfListener(e, t);return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), e;
    }, removeAll: function removeAll(e) {
      "undefined" == typeof e && (e = null);for (var t = this._bindings.length; t--;) {
        e ? this._bindings[t].context === e && (this._bindings[t]._destroy(), this._bindings.splice(t, 1)) : this._bindings[t]._destroy();
      }e || (this._bindings.length = 0);
    }, getNumListeners: function getNumListeners() {
      return this._bindings.length;
    }, halt: function halt() {
      this._shouldPropagate = !1;
    }, dispatch: function dispatch() {
      if (this.active) {
        var e,
            t = Array.prototype.slice.call(arguments),
            i = this._bindings.length;if (this.memorize && (this._prevParams = t), i) {
          e = this._bindings.slice(), this._shouldPropagate = !0;do {
            i--;
          } while (e[i] && this._shouldPropagate && e[i].execute(t) !== !1);
        }
      }
    }, forget: function forget() {
      this._prevParams = null;
    }, dispose: function dispose() {
      this.removeAll(), delete this._bindings, delete this._prevParams;
    }, toString: function toString() {
      return "[Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
    } }, t.prototype.constructor = t, vg.Signal = t;
}(), vg.AStarFinder = function (e) {
  e = e || {};var t = { allowDiagonal: !1, heuristicFilter: null };t = vg.Tools.merge(t, e), this.allowDiagonal = t.allowDiagonal, this.heuristicFilter = t.heuristicFilter, this.list = new vg.LinkedList();
}, vg.AStarFinder.prototype = { findPath: function findPath(e, t, i, s) {
    var n, l, r, h, o, a;for (i = i || this.heuristicFilter, s.clearPath(), this.list.clear(), this.list.add(e); this.list.length > 0;) {
      if (this.list.sort(this.compare), n = this.list.shift(), n._visited = !0, n === t) return vg.PathUtil.backtrace(t);for (r = s.getNeighbors(n, this.allowDiagonal, i), o = 0, a = r.length; a > o; o++) {
        if (h = r[o], h.walkable && (l = n._calcCost + s.distance(n, h), !h._visited || l < h._calcCost)) {
          if (h._visited = !0, h._parent = n, h._calcCost = l, h._priority = l + s.distance(t, h), h === t) return vg.PathUtil.backtrace(t);this.list.add(h);
        }
      }
    }return null;
  }, compare: function compare(e, t) {
    return e._priority - t._priority;
  } }, vg.AStarFinder.prototype.constructor = vg.AStarFinder, vg.PathUtil = { backtrace: function backtrace(e) {
    for (var t = [e]; e._parent;) {
      e = e._parent, t.push(e);
    }return t.reverse();
  }, biBacktrace: function biBacktrace(e, t) {
    var i = this.backtrace(e),
        s = this.backtrace(t);return i.concat(s.reverse());
  }, pathLength: function pathLength(e) {
    var t,
        i,
        s,
        n,
        l,
        r = 0;for (t = 1; t < e.length; ++t) {
      i = e[t - 1], s = e[t], n = i[0] - s[0], l = i[1] - s[1], r += Math.sqrt(n * n + l * l);
    }return r;
  }, interpolate: function interpolate(e, t, i, s) {
    var n,
        l,
        r,
        h,
        o,
        a,
        c = Math.abs,
        u = [];for (r = c(i - e), h = c(s - t), n = i > e ? 1 : -1, l = s > t ? 1 : -1, o = r - h; e !== i || t !== s;) {
      u.push([e, t]), a = 2 * o, a > -h && (o -= h, e += n), r > a && (o += r, t += l);
    }return u;
  }, expandPath: function expandPath(e) {
    var t,
        i,
        s,
        n,
        l,
        r,
        h = [],
        o = e.length;if (2 > o) return h;for (l = 0; o - 1 > l; ++l) {
      for (t = e[l], i = e[l + 1], s = this.interpolate(t[0], t[1], i[0], i[1]), n = s.length, r = 0; n - 1 > r; ++r) {
        h.push(s[r]);
      }
    }return h.push(e[o - 1]), h;
  }, smoothenPath: function smoothenPath(e, t) {
    var i,
        s,
        n,
        l,
        r,
        h,
        o,
        a,
        c,
        u,
        d,
        g,
        p = t.length,
        v = t[0][0],
        f = t[0][1],
        m = t[p - 1][0],
        _ = t[p - 1][1];for (i = v, s = f, r = [[i, s]], o = 2; p > o; ++o) {
      for (c = t[o], n = c[0], l = c[1], u = this.interpolate(i, s, n, l), g = !1, a = 1; a < u.length; ++a) {
        if (d = u[a], !e.isWalkableAt(d[0], d[1])) {
          g = !0;break;
        }
      }g && (h = t[o - 1], r.push(h), i = h[0], s = h[1]);
    }return r.push([m, _]), r;
  }, compressPath: function compressPath(e) {
    if (e.length < 3) return e;var t,
        i,
        s,
        n,
        l,
        r,
        h = [],
        o = e[0][0],
        a = e[0][1],
        c = e[1][0],
        u = e[1][1],
        d = c - o,
        g = u - a;for (l = Math.sqrt(d * d + g * g), d /= l, g /= l, h.push([o, a]), r = 2; r < e.length; r++) {
      t = c, i = u, s = d, n = g, c = e[r][0], u = e[r][1], d = c - t, g = u - i, l = Math.sqrt(d * d + g * g), d /= l, g /= l, (d !== s || g !== n) && h.push([t, i]);
    }return h.push([c, u]), h;
  } }, vg.Loader = { manager: null, imageLoader: null, crossOrigin: !1, init: function init(e) {
    this.crossOrigin = e || !1, this.manager = new THREE.LoadingManager(function () {}, function () {}, function () {
      console.warn("Error loading images");
    }), this.imageLoader = new THREE.ImageLoader(this.manager), this.imageLoader.crossOrigin = e;
  }, loadTexture: function loadTexture(e, t, i, s) {
    var n = new THREE.Texture(null, t);return this.imageLoader.load(e, function (e) {
      n.image = e, n.needsUpdate = !0, i && i(n);
    }, null, function (e) {
      s && s(e);
    }), n.sourceFile = e, n;
  } }, vg.MouseCaster = function (e, t, i) {
  this.down = !1, this.rightDown = !1, this.pickedObject = null, this.selectedObject = null, this.allHits = null, this.active = !0, this.shift = !1, this.ctrl = !1, this.wheel = 0, this.position = new THREE.Vector3(), this.screenPosition = new THREE.Vector2(), this.signal = new vg.Signal(), this.group = e, this._camera = t, this._raycaster = new THREE.Raycaster(), this._preventDefault = !1, i = i || document, i.addEventListener("mousemove", this._onDocumentMouseMove.bind(this), !1), i.addEventListener("mousedown", this._onDocumentMouseDown.bind(this), !1), i.addEventListener("mouseup", this._onDocumentMouseUp.bind(this), !1), i.addEventListener("mousewheel", this._onMouseWheel.bind(this), !1), i.addEventListener("DOMMouseScroll", this._onMouseWheel.bind(this), !1);
}, vg.MouseCaster.OVER = "over", vg.MouseCaster.OUT = "out", vg.MouseCaster.DOWN = "down", vg.MouseCaster.UP = "up", vg.MouseCaster.CLICK = "click", vg.MouseCaster.WHEEL = "wheel", vg.MouseCaster.prototype = { update: function update() {
    if (this.active) {
      this._raycaster.setFromCamera(this.screenPosition, this._camera);var e,
          t,
          i = this._raycaster.intersectObject(this.group, !0);i.length > 0 ? (e = i[0], t = e.object.userData.structure, this.pickedObject != t && (this.pickedObject && this.signal.dispatch(vg.MouseCaster.OUT, this.pickedObject), this.pickedObject = t, this.selectedObject = null, this.signal.dispatch(vg.MouseCaster.OVER, this.pickedObject)), this.position.copy(e.point), this.screenPosition.z = e.distance) : (this.pickedObject && this.signal.dispatch(vg.MouseCaster.OUT, this.pickedObject), this.pickedObject = null, this.selectedObject = null), this.allHits = i;
    }
  }, preventDefault: function preventDefault() {
    this._preventDefault = !0;
  }, _onDocumentMouseDown: function _onDocumentMouseDown(e) {
    return e = e || window.event, e.preventDefault(), this._preventDefault ? (this._preventDefault = !1, !1) : (this.pickedObject && (this.selectedObject = this.pickedObject), this.shift = e.shiftKey, this.ctrl = e.ctrlKey, this.down = 1 === e.which, this.rightDown = 3 === e.which, void this.signal.dispatch(vg.MouseCaster.DOWN, this.pickedObject));
  }, _onDocumentMouseUp: function _onDocumentMouseUp(e) {
    return e.preventDefault(), this._preventDefault ? (this._preventDefault = !1, !1) : (this.shift = e.shiftKey, this.ctrl = e.ctrlKey, this.signal.dispatch(vg.MouseCaster.UP, this.pickedObject), this.selectedObject && this.pickedObject && this.selectedObject.uniqueID === this.pickedObject.uniqueID && this.signal.dispatch(vg.MouseCaster.CLICK, this.pickedObject), this.down = 1 === e.which ? !1 : this.down, void (this.rightDown = 3 === e.which ? !1 : this.rightDown));
  }, _onDocumentMouseMove: function _onDocumentMouseMove(e) {
    e.preventDefault(), this.screenPosition.x = e.clientX / window.innerWidth * 2 - 1, this.screenPosition.y = 2 * -(e.clientY / window.innerHeight) + 1;
  }, _onMouseWheel: function _onMouseWheel(e) {
    if (this.active) {
      e.preventDefault(), e.stopPropagation();var t = 0;void 0 !== e.wheelDelta ? t = e.wheelDelta : void 0 !== e.detail && (t = -e.detail), t > 0 ? this.wheel++ : this.wheel--, this.signal.dispatch(vg.MouseCaster.WHEEL, this.wheel);
    }
  } }, vg.MouseCaster.prototype.constructor = vg.MouseCaster, vg.Scene = function (e, t) {
  var i = { element: document.body, alpha: !0, antialias: !0, clearColor: "#fff", sortObjects: !1, fog: null, light: new THREE.DirectionalLight(16777215), lightPosition: null, cameraType: "PerspectiveCamera", cameraPosition: null, orthoZoom: 4 },
      s = { minDistance: 100, maxDistance: 1e3, zoomSpeed: 2, noZoom: !1 };if (i = vg.Tools.merge(i, e), "boolean" != typeof t && (s = vg.Tools.merge(s, t)), this.renderer = new THREE.WebGLRenderer({ alpha: i.alpha, antialias: i.antialias }), this.renderer.setClearColor(i.clearColor, 0), this.renderer.sortObjects = i.sortObjects, this.width = window.innerWidth, this.height = window.innerHeight, this.orthoZoom = i.orthoZoom, this.container = new THREE.Scene(), this.container.fog = i.fog, this.container.add(new THREE.AmbientLight(14540253)), i.lightPosition || i.light.position.set(-1, 1, -1).normalize(), this.container.add(i.light), "OrthographicCamera" === i.cameraType) {
    var n = window.innerWidth / this.orthoZoom,
        l = window.innerHeight / this.orthoZoom;this.camera = new THREE.OrthographicCamera(n / -2, n / 2, l / 2, l / -2, 1, 5e3);
  } else this.camera = new THREE.PerspectiveCamera(50, this.width / this.height, 1, 5e3);this.contolled = !!t, this.contolled && (this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement), this.controls.minDistance = s.minDistance, this.controls.maxDistance = s.maxDistance, this.controls.zoomSpeed = s.zoomSpeed, this.controls.noZoom = s.noZoom), i.cameraPosition && this.camera.position.copy(i.cameraPosition), window.addEventListener("resize", function () {
    if (this.width = window.innerWidth, this.height = window.innerHeight, "OrthographicCamera" === this.camera.type) {
      var e = this.width / this.orthoZoom,
          t = this.height / this.orthoZoom;this.camera.left = e / -2, this.camera.right = e / 2, this.camera.top = t / 2, this.camera.bottom = t / -2;
    } else this.camera.aspect = this.width / this.height;this.camera.updateProjectionMatrix(), this.renderer.setSize(this.width, this.height);
  }.bind(this), !1), this.attachTo(i.element);
}, vg.Scene.prototype = { attachTo: function attachTo(e) {
    e.style.width = this.width + "px", e.style.height = this.height + "px", this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.width, this.height), e.appendChild(this.renderer.domElement);
  }, add: function add(e) {
    this.container.add(e);
  }, remove: function remove(e) {
    this.container.remove(e);
  }, render: function render() {
    this.contolled && this.controls.update(), this.renderer.render(this.container, this.camera);
  }, updateOrthoZoom: function updateOrthoZoom() {
    if (this.orthoZoom <= 0) return void (this.orthoZoom = 0);var e = this.width / this.orthoZoom,
        t = this.height / this.orthoZoom;this.camera.left = e / -2, this.camera.right = e / 2, this.camera.top = t / 2, this.camera.bottom = t / -2, this.camera.updateProjectionMatrix();
  }, focusOn: function focusOn(e) {
    this.camera.lookAt(e.position);
  } }, vg.Scene.prototype.constructor = vg.Scene, vg.SelectionManager = function (e) {
  this.mouse = e, this.onSelect = new vg.Signal(), this.onDeselect = new vg.Signal(), this.selected = null, this.toggleSelection = !1, this.mouse.signal.add(this.onMouse, this);
}, vg.SelectionManager.prototype = { select: function select(e, t) {
    e && (t = t || !0, this.selected !== e && this.clearSelection(t), e.selected ? this.toggleSelection && (t && this.onDeselect.dispatch(e), e.deselect()) : e.select(), this.selected = e, t && this.onSelect.dispatch(e));
  }, clearSelection: function clearSelection(e) {
    e = e || !0, this.selected && (e && this.onDeselect.dispatch(this.selected), this.selected.deselect()), this.selected = null;
  }, onMouse: function onMouse(e, t) {
    switch (e) {case vg.MouseCaster.DOWN:
        t || this.clearSelection();break;case vg.MouseCaster.CLICK:
        this.select(t);}
  } }, vg.SelectionManager.prototype.constructor = vg.SelectionManager, vg.Tools = { clamp: function clamp(e, t, i) {
    return Math.max(t, Math.min(i, e));
  }, sign: function sign(e) {
    return e && e / Math.abs(e);
  }, random: function random(e, t) {
    return 1 === arguments.length ? Math.random() * e - .5 * e : Math.random() * (t - e) + e;
  }, randomInt: function randomInt(e, t) {
    return 1 === arguments.length ? Math.random() * e - .5 * e | 0 : Math.random() * (t - e + 1) + e | 0;
  }, normalize: function normalize(e, t, i) {
    return (e - t) / (i - t);
  }, getShortRotation: function getShortRotation(e) {
    return e %= this.TAU, e > this.PI ? e -= this.TAU : e < -this.PI && (e += this.TAU), e;
  }, generateID: function generateID() {
    return Math.random().toString(36).slice(2) + Date.now();
  }, isPlainObject: function isPlainObject(e) {
    if ("object" != (typeof e === "undefined" ? "undefined" : _typeof(e)) || e.nodeType || e === e.window) return !1;try {
      if (e.constructor && !Object.prototype.hasOwnProperty.call(e.constructor.prototype, "isPrototypeOf")) return !1;
    } catch (t) {
      return !1;
    }return !0;
  }, merge: function merge(e, t) {
    var i = this,
        s = Array.isArray(t),
        n = s && [] || {};return s ? (e = e || [], n = n.concat(e), t.forEach(function (t, s) {
      "undefined" == typeof n[s] ? n[s] = t : i.isPlainObject(t) ? n[s] = i.merge(e[s], t) : -1 === e.indexOf(t) && n.push(t);
    }), n) : (e && i.isPlainObject(e) && Object.keys(e).forEach(function (t) {
      n[t] = e[t];
    }), Object.keys(t).forEach(function (s) {
      t[s] && i.isPlainObject(t[s]) && e[s] ? n[s] = i.merge(e[s], t[s]) : n[s] = t[s];
    }), n);
  }, now: function now() {
    return window.nwf ? window.nwf.system.Performance.elapsedTime : window.performance.now();
  }, empty: function empty(e) {
    for (; e.lastChild;) {
      e.removeChild(e.lastChild);
    }
  }, radixSort: function radixSort(e, t, i, s) {
    if (t = t || 0, i = i || e.length, s = s || 31, !(t >= i - 1 || 0 > s)) {
      for (var n = t, l = i, r = 1 << s; l > n;) {
        if (e[n] & r) {
          --l;var h = e[n];e[n] = e[l], e[l] = h;
        } else ++n;
      }this.radixSort(e, t, l, s - 1), this.radixSort(e, l, i, s - 1);
    }
  }, randomizeRGB: function randomizeRGB(e, t) {
    var i,
        s,
        n = e.split(","),
        l = "rgb(";for (t = this.randomInt(t), i = 0; 3 > i; i++) {
      s = parseInt(n[i]) + t, 0 > s ? s = 0 : s > 255 && (s = 255), l += s + ",";
    }return l = l.substring(0, l.length - 1), l += ")";
  }, getJSON: function getJSON(e) {
    var t = new XMLHttpRequest(),
        i = "undefined" == typeof e.cache ? !1 : e.cache,
        s = i ? e.url : e.url + "?t=" + Math.floor(1e4 * Math.random()) + Date.now();t.onreadystatechange = function () {
      if (200 === this.status) {
        var t = null;try {
          t = JSON.parse(this.responseText);
        } catch (i) {
          return;
        }return void e.callback.call(e.scope || null, t);
      }0 !== this.status && console.warn("[Tools.getJSON] Error: " + this.status + " (" + this.statusText + ") :: " + e.url);
    }, t.open("GET", s, !0), t.setRequestHeader("Accept", "application/json"), t.setRequestHeader("Content-Type", "application/json"), t.send("");
  } };


},{}],4:[function(require,module,exports){
'use strict';

/**
 * Flat grid.
 *
 * Defaults to 75x75.
 */

module.exports = AFRAME.registerPrimitive('a-grid', {
  defaultComponents: {
    geometry: {
      primitive: 'plane',
      width: 75,
      height: 75
    },
    rotation: { x: -90, y: 0, z: 0 },
    material: {
      src: 'url(https://cdn.rawgit.com/donmccurdy/aframe-extras/v1.16.3/assets/grid.png)',
      repeat: '75 75'
    }
  },
  mappings: {
    width: 'geometry.width',
    height: 'geometry.height',
    src: 'material.src'
  }
});

},{}],5:[function(require,module,exports){
'use strict';

var vg = require('../../lib/hex-grid.min.js');
var defaultHexGrid = require('../../lib/default-hex-grid');

/**
 * Hex grid.
 */
module.exports.Primitive = AFRAME.registerPrimitive('a-hexgrid', {
  defaultComponents: {
    'hexgrid': {}
  },
  mappings: {
    src: 'hexgrid.src'
  }
});

module.exports.Component = AFRAME.registerComponent('hexgrid', {
  dependencies: ['material'],
  schema: {
    src: { type: 'asset' }
  },
  init: function init() {
    var _this = this;

    var data = this.data;
    if (data.src) {
      fetch(data.src).then(function (response) {
        return response.json();
      }).then(function (json) {
        return _this.addMesh(json);
      });
    } else {
      this.addMesh(defaultHexGrid);
    }
  },
  addMesh: function addMesh(json) {
    var grid = new vg.HexGrid();
    grid.fromJSON(json);
    var board = new vg.Board(grid);
    board.generateTilemap();
    this.el.setObject3D('mesh', board.group);
    this.addMaterial();
  },
  addMaterial: function addMaterial() {
    var materialComponent = this.el.components.material;
    var material = (materialComponent || {}).material;
    if (!material) return;
    this.el.object3D.traverse(function (node) {
      if (node.isMesh) {
        node.material = material;
      }
    });
  },
  remove: function remove() {
    this.el.removeObject3D('mesh');
  }
});

},{"../../lib/default-hex-grid":2,"../../lib/hex-grid.min.js":3}],6:[function(require,module,exports){
'use strict';

/**
 * Flat-shaded ocean primitive.
 *
 * Based on a Codrops tutorial:
 * http://tympanus.net/codrops/2016/04/26/the-aviator-animating-basic-3d-scene-threejs/
 */

module.exports.Primitive = AFRAME.registerPrimitive('a-ocean', {
  defaultComponents: {
    ocean: {},
    rotation: { x: -90, y: 0, z: 0 }
  },
  mappings: {
    width: 'ocean.width',
    depth: 'ocean.depth',
    density: 'ocean.density',
    amplitude: 'ocean.amplitude',
    amplitudeVariance: 'ocean.amplitudeVariance',
    speed: 'ocean.speed',
    speedVariance: 'ocean.speedVariance',
    color: 'ocean.color',
    opacity: 'ocean.opacity'
  }
});

module.exports.Component = AFRAME.registerComponent('ocean', {
  schema: {
    // Dimensions of the ocean area.
    width: { default: 10, min: 0 },
    depth: { default: 10, min: 0 },

    // Density of waves.
    density: { default: 10 },

    // Wave amplitude and variance.
    amplitude: { default: 0.1 },
    amplitudeVariance: { default: 0.3 },

    // Wave speed and variance.
    speed: { default: 1 },
    speedVariance: { default: 2 },

    // Material.
    color: { default: '#7AD2F7', type: 'color' },
    opacity: { default: 0.8 }
  },

  /**
   * Use play() instead of init(), because component mappings – unavailable as dependencies – are
   * not guaranteed to have parsed when this component is initialized.
   */
  play: function play() {
    var el = this.el,
        data = this.data;
    var material = el.components.material;

    var geometry = new THREE.PlaneGeometry(data.width, data.depth, data.density, data.density);
    geometry.mergeVertices();
    this.waves = [];
    for (var v, i = 0, l = geometry.vertices.length; i < l; i++) {
      v = geometry.vertices[i];
      this.waves.push({
        z: v.z,
        ang: Math.random() * Math.PI * 2,
        amp: data.amplitude + Math.random() * data.amplitudeVariance,
        speed: (data.speed + Math.random() * data.speedVariance) / 1000 // radians / frame
      });
    }

    if (!material) {
      material = {};
      material.material = new THREE.MeshPhongMaterial({
        color: data.color,
        transparent: data.opacity < 1,
        opacity: data.opacity,
        shading: THREE.FlatShading
      });
    }

    this.mesh = new THREE.Mesh(geometry, material.material);
    el.setObject3D('mesh', this.mesh);
  },

  remove: function remove() {
    this.el.removeObject3D('mesh');
  },

  tick: function tick(t, dt) {
    if (!dt) return;

    var verts = this.mesh.geometry.vertices;
    for (var v, vprops, i = 0; v = verts[i]; i++) {
      vprops = this.waves[i];
      v.z = vprops.z + Math.sin(vprops.ang) * vprops.amp;
      vprops.ang += vprops.speed * dt;
    }
    this.mesh.geometry.verticesNeedUpdate = true;
  }
});

},{}],7:[function(require,module,exports){
'use strict';

/**
 * Tube following a custom path.
 *
 * Usage:
 *
 * ```html
 * <a-tube path="5 0 5, 5 0 -5, -5 0 -5" radius="0.5"></a-tube>
 * ```
 */

module.exports.Primitive = AFRAME.registerPrimitive('a-tube', {
  defaultComponents: {
    tube: {}
  },
  mappings: {
    path: 'tube.path',
    segments: 'tube.segments',
    radius: 'tube.radius',
    'radial-segments': 'tube.radialSegments',
    closed: 'tube.closed'
  }
});

module.exports.Component = AFRAME.registerComponent('tube', {
  schema: {
    path: { default: [] },
    segments: { default: 64 },
    radius: { default: 1 },
    radialSegments: { default: 8 },
    closed: { default: false }
  },

  init: function init() {
    var el = this.el,
        data = this.data;
    var material = el.components.material;

    if (!data.path.length) {
      console.error('[a-tube] `path` property expected but not found.');
      return;
    }

    var curve = new THREE.CatmullRomCurve3(data.path.map(function (point) {
      point = point.split(' ');
      return new THREE.Vector3(Number(point[0]), Number(point[1]), Number(point[2]));
    }));
    var geometry = new THREE.TubeGeometry(curve, data.segments, data.radius, data.radialSegments, data.closed);

    if (!material) {
      material = {};
      material.material = new THREE.MeshPhongMaterial();
    }

    this.mesh = new THREE.Mesh(geometry, material.material);
    this.el.setObject3D('mesh', this.mesh);
  },

  update: function update(prevData) {
    if (!Object.keys(prevData).length) return;

    this.remove();
    this.init();
  },

  remove: function remove() {
    if (this.mesh) this.el.removeObject3D('mesh');
  }
});

},{}],8:[function(require,module,exports){
'use strict';

require('./a-grid');
require('./a-hexgrid');
require('./a-ocean');
require('./a-tube');

},{"./a-grid":4,"./a-hexgrid":5,"./a-ocean":6,"./a-tube":7}]},{},[1]);
