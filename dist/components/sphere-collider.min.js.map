{"version":3,"file":"components/sphere-collider.min.js","mappings":"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","sources":["webpack://aframe-extras/webpack/universalModuleDefinition","webpack://aframe-extras/./src/misc/sphere-collider.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","/**\n * Based on aframe/examples/showcase/tracked-controls.\n *\n * Implement bounding sphere collision detection for entities with a mesh.\n * Sets the specified state on the intersected entities.\n *\n * @property {string} objects - Selector of the entities to test for collision.\n * @property {string} state - State to set on collided entities.\n *\n */\nAFRAME.registerComponent('sphere-collider', {\n  schema: {\n    enabled: {default: true},\n    interval: {default: 80},\n    objects: {default: ''},\n    state: {default: 'collided'},\n    radius: {default: 0.05},\n    watch: {default: true}\n  },\n\n  init: function () {\n    /** @type {MutationObserver} */\n    this.observer = null;\n    /** @type {Array<Element>} Elements to watch for collisions. */\n    this.els = [];\n    /** @type {Array<Element>} Elements currently in collision state. */\n    this.collisions = [];\n    this.prevCheckTime = undefined;\n\n    this.eventDetail = {};\n    this.handleHit = this.handleHit.bind(this);\n    this.handleHitEnd = this.handleHitEnd.bind(this);\n  },\n\n  play: function () {\n    const sceneEl = this.el.sceneEl;\n\n    if (this.data.watch) {\n      this.observer = new MutationObserver(this.update.bind(this, null));\n      this.observer.observe(sceneEl, {childList: true, subtree: true});\n    }\n  },\n\n  pause: function () {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  },\n\n  /**\n   * Update list of entities to test for collision.\n   */\n  update: function () {\n    const data = this.data;\n    let objectEls;\n\n    // Push entities into list of els to intersect.\n    if (data.objects) {\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\n    } else {\n      // If objects not defined, intersect with everything.\n      objectEls = this.el.sceneEl.children;\n    }\n    // Convert from NodeList to Array\n    this.els = Array.prototype.slice.call(objectEls);\n  },\n\n  tick: (function () {\n    const position = new THREE.Vector3(),\n        meshPosition = new THREE.Vector3(),\n        colliderScale = new THREE.Vector3(),\n        size = new THREE.Vector3(),\n        box = new THREE.Box3(),\n        collisions = [],\n        distanceMap = new Map();\n    return function (time) {\n      if (!this.data.enabled) { return; }\n\n      // Only check for intersection if interval time has passed.\n      const prevCheckTime = this.prevCheckTime;\n      if (prevCheckTime && (time - prevCheckTime < this.data.interval)) { return; }\n      // Update check time.\n      this.prevCheckTime = time;\n\n      const el = this.el,\n          data = this.data,\n          mesh = el.getObject3D('mesh');\n      let colliderRadius;\n\n      if (!mesh) { return; }\n\n      collisions.length = 0;\n      distanceMap.clear();\n      el.object3D.getWorldPosition(position);\n      el.object3D.getWorldScale(colliderScale);\n      colliderRadius = data.radius * scaleFactor(colliderScale);\n      // Update collision list.\n      this.els.forEach(intersect);\n\n      // Emit events and add collision states, in order of distance.\n      collisions\n        .sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1)\n        .forEach(this.handleHit);\n\n      // Remove collision state from other elements.\n      this.collisions\n        .filter((el) => !distanceMap.has(el))\n        .forEach(this.handleHitEnd);\n\n      // Store new collisions\n      copyArray(this.collisions, collisions);\n\n      // Bounding sphere collision detection\n      function intersect (el) {\n        let radius, mesh, distance, extent;\n\n        if (!el.isEntity) { return; }\n\n        mesh = el.getObject3D('mesh');\n\n        if (!mesh) { return; }\n\n        box.setFromObject(mesh).getSize(size);\n        extent = Math.max(size.x, size.y, size.z) / 2;\n        radius = Math.sqrt(2 * extent * extent);\n        box.getCenter(meshPosition);\n\n        if (!radius) { return; }\n\n        distance = position.distanceTo(meshPosition);\n        if (distance < radius + colliderRadius) {\n          collisions.push(el);\n          distanceMap.set(el, distance);\n        }\n      }\n      // use max of scale factors to maintain bounding sphere collision\n      function scaleFactor (scaleVec) {\n        return Math.max(scaleVec.x, scaleVec.y, scaleVec.z);\n      }\n    };\n  })(),\n\n  handleHit: function (targetEl) {\n    targetEl.emit('hit');\n    targetEl.addState(this.data.state);\n    this.eventDetail.el = targetEl;\n    this.el.emit('hit', this.eventDetail);\n  },\n  handleHitEnd: function (targetEl) {\n    targetEl.emit('hitend');\n    targetEl.removeState(this.data.state);\n    this.eventDetail.el = targetEl;\n    this.el.emit('hitend', this.eventDetail);\n  }\n});\n\nfunction copyArray (dest, source) {\n  dest.length = 0;\n  for (let i = 0; i < source.length; i++) { dest[i] = source[i]; }\n}\n"],"names":["root","factory","exports","module","define","amd","a","i","self","AFRAME","registerComponent","schema","enabled","default","interval","objects","state","radius","watch","init","this","observer","els","collisions","prevCheckTime","undefined","eventDetail","handleHit","bind","handleHitEnd","play","sceneEl","el","data","MutationObserver","update","observe","childList","subtree","pause","disconnect","objectEls","querySelectorAll","children","Array","prototype","slice","call","tick","position","THREE","Vector3","meshPosition","colliderScale","size","box","Box3","distanceMap","Map","time","colliderRadius","scaleVec","getObject3D","length","clear","object3D","getWorldPosition","getWorldScale","Math","max","x","y","z","forEach","mesh","distance","extent","isEntity","setFromObject","getSize","sqrt","getCenter","distanceTo","push","set","sort","b","get","filter","has","dest","source","copyArray","targetEl","emit","addState","removeState"],"sourceRoot":""}